/*
Implementation of force.h.  For comments on how to use these functions, visit force.h.  Comments in this file
are related to implementation, not usage.
*/

#include <math.h>
#include <stdlib.h>
#include <vector>
#include <algorithm>

#include "AU_UAV_ROS/force.h"
#include "AU_UAV_ROS/standardFuncs.h"		// for PI, EARTH_RADIUS, MPS_SPEED
#include "AU_UAV_ROS/SimulatedPlane.h"		// for MAXIMUM_TURNING_ANGLE
#define EPSILON 1e-4						// used to check floating point numbers for equality
#define LOOPING_DISTANCE 4*MPS_SPEED		// When distance to destination is less than this distance, we should start checking for looping
#define LOOP_RADIUS 28.64058013			// Turning radius of the UAV = MPS_SPEED/sin(MAXIMUM_TURNING_ANGLE)*sin((180-MAXIMUM_TURNING_ANGLE)/2)
						// Because the simulator assumes straight turns, we used the law of sines to find the distance from the
						// points on the perimeter of the hexadecagon generated by a looping UAV to the center of hexadecagon

#define DEST_CHARGE 100 			//Amount of positive charge given to a destination waypoint.
#define PRIORITY_DISTANCE 50 		//How close a plane must be to its destination to become considered for having priority (in meters).
#define FRONT_FEEL 1.0 				//The percent of calculated charge a plane will feel from the front (pushing plane "backwards")
#define	BACK_FEEL 0.5 				//The percent of calculated charge a plane will feel from the back (pushing plane "forwards")

/*
The calculateForces method is the primary method in the force.cpp file.  Calling this
method will result in subsequent calls to all other methods in this file.  
*/
AU_UAV_ROS::mathVector AU_UAV_ROS::calculateForces(PlaneObject &pobj1, std::map<int, PlaneObject> &pobjects, std::vector<std::vector<AU_UAV_ROS::PlaneObject*> > flocks, AU_UAV_ROS::forceVariables forceVars){
	double distance = 0.0, rAngle = 0.0, fieldAngle = 0.0, maxDistance = 0.0;
	mathVector rForce(0.0, 0.0), aForce(0.0, 0.0), tForce(1.0, 0.0), aForceUnit(0.0, 0.0), rForceUnit(0.0, 0.0);

	//calculate the attraction force
	aForce = calculateAttractionForce(pobj1, pobjects);

	for (unsigned int i = 0; i < flocks.size(); i += 1) {
		mathVector flockForce1(0.0, 0.0), flockForce2(0.0, 0.0), rToBearing(0.0, 0.0);
		for (unsigned int j = 0; j < flocks[i].size(); j += 1){
			
			double distToDest = findDistance(flocks[i][j]->getLatitude(), flocks[i][j]->getLongitude(), 
								flocks[i][j]->getDestination().latitude, flocks[i][j]->getDestination().longitude);
			
			if(flocks[i][j]->getID() == pobj1.getID() && distToDest < PRIORITY_DISTANCE){ 
				//This plane has priority over the rest so we don't need to calculate further forces.
				break;
			}

			else if(flocks[i][j]->getID() == pobj1.getID()){
				//these are the same plane...do nothing
			}
			else{
				if (flocks[pobj1.getFlock()].size() > 1){ // this plane has followers		
				
					if (pobj1.getFlock() == flocks[i][j]->getFlock()) {
						// these planes are in the same flock, ignore the APF
					}
					else{
						// this plane's APF matters- calculate it and take it into account
						goto useFoce;	
					}
				}
				
				else{						// this plane does not have followers
					useFoce:

					//find angle between the bearing of flocks[i][j] and pobj1 
					fieldAngle = manipulateAngle(flocks[i][j]->findAngle(pobj1) - flocks[i][j]->getBearing());
		
					//find angle of repulsive force with respect to Cartesian coordinates
					rAngle = toCartesian(pobj1.findAngle(*flocks[i][j]) - 180);

					// find distance between pobj1 and flocks[i][j]
					distance = pobj1.findDistance(*flocks[i][j]);
					
					// find the force
					mathVector currentForce = calculateRepulsionForce(pobj1, distance, maxDistance, rAngle, fieldAngle, aForce.getDirection(), forceVars);
					
					//Calculates angle between pobj1's bearing and the direction of repulsion force.
					rToBearing = manipulateAngle(toCartesian(pobj1.getBearing()) - rAngle);
					
					// only take the 2 strongest forces from a flock, so we don't have too many overlapping forces from a single flock overpowering other UAVs
					if(currentForce.getMagnitude() > flockForce1.getMagnitude() || currentForce.getMagnitude() > flockForce2.getMagnitude()){
						if (flockForce1.getMagnitude() > flockForce2.getMagnitude()){
							flockForce2 = currentForce;
						}
						else if (flockForce1.getMagnitude() < flockForce2.getMagnitude() || flockForce1.getMagnitude() == flockForce2.getMagnitude())
						{
							flockForce1 = currentForce;
						}
						else std::cout << "Force storing error: this should never happen" << std::endl;
					}
				}
			}
		}
		rForce += flockForce1 + flockForce2;
	}
	
	//Get unit vectors for forces
	aForceUnit = aForce;
	aForceUnit.setMagnitude(1);

	rForceUnit = rForce;
	if(rForceUnit.getMagnitude() > 0)
		rForceUnit.setMagnitude(1);

	//Use unit vectors to fix head on collisions
	if ((aForceUnit + rForceUnit).getMagnitude() < EPSILON){
		//give the planes a "nudge" to the right to break deadlock
		double newDirection = manipulateAngle(aForce.getDirection() - 15);

		tForce.setDirection(newDirection);
	}
	else{
		//calculate total force
		tForce = aForce + rForce;

		//Check to see if this total force will put plane in a loop
		if (inLoop(pobj1, tForce)){ 
			//pobj1 is in a loop, modify attractive force so that the destination is actually repulsive to break the cycle
			aForce.setDirection(manipulateAngle(aForce.getDirection() + 180));
			
			//we changed aForce so now need to recalculate tForce
			tForce = aForce + rForce;
		}
		
		//Make sure resulting force angle does not exceed turning angle of plane
		makeForceViable(pobj1, tForce);
	}
	return tForce;
}

/*
Calculates the repulsion force between two planes.
The distance parameter is the distance between the planes in meters, maxDistance is
the distance over which field pobj1 is in acts, rAngle is the angle of the repulsive force, 
fieldAngle is the angle between the bearing of the plane generating the force to the location
of pobj1, and aAngle is the angle between the bearing of pobj1 and the location of its destination.
All angles are in the Cartesian plane.
*/
AU_UAV_ROS::mathVector AU_UAV_ROS::calculateRepulsionForce(const PlaneObject &pobj1, double distance, 
							double maxDistance, double rAngle, double fieldAngle, double aAngle, AU_UAV_ROS::forceVariables forceVars){
	double rForce = 0.0, rToBearing = 0.0;

	//If getting close to conflict zone, max repulsion.
	if(distance <= 2.5*MPS_SPEED){
		rForce = 99999;
	}else{
		//calculates the repulsive force emitted from other plane based on fieldAngle from which pobj1 is approaching
		//and whether the plane is a follower in a swarm
		//fieldAngle is in degrees

		bool activateForce = false;
	
		//find the difference in x and y based on field-generating plane's POV
		double y = distance*cos(fieldAngle * PI / 180);
		double x = distance*sin(fieldAngle * PI / 180);

		if(pobj1.getLeader() == -1){		// if the plane is independent or is a swarm leader

			//find the limits of the APF field- the constants here are part of the egg shape
			//figure out if self is within the limit of the force field
			if (fieldAngle > 90 && fieldAngle <270){
				// plane generating the force is behind, therefore use the bottom boundary	
				double forceLimit = -sqrt((forceVars.gamma-(forceVars.alphaBot*pow(x,2)))/forceVars.betaBot);
				if (y>forceLimit) activateForce = true;
			}
			else{
				// plane generating the force is in front, therefore use the top boundary
				double forceLimit = sqrt((forceVars.gamma-(forceVars.alphaTop*pow(x,2)))/forceVars.betaTop);
				if (y<forceLimit) activateForce = true;
			}
		}
		
		else if (pobj1.getLeader() != -1) {	// if the plane has a leader			
			//find the limits of the APF field- the constants here are part of the egg shape
			//figure out if self is within the limit of the force field
			if (fieldAngle > 90 && fieldAngle <270){
				// plane generating the force is behind, therefore use the bottom boundary			
				double forceLimit = -sqrt((forceVars.gamma-(forceVars.alphaBotF*pow(x,2)))/forceVars.betaBotF);
				if (y>forceLimit) activateForce = true;
			}
			else{
				// plane generating the force is in front, therefore use the top boundary
				double forceLimit = sqrt((forceVars.gamma-(forceVars.alphaTopF*pow(x,2)))/forceVars.betaTopF);
				if (y<forceLimit) activateForce = true;
			}
		}
		else std::cout << "error: this should never happen... there's a problem with the swarm APF" << std::endl;
	
		if (activateForce) rForce = forceVars.maxForce * exp(-forceVars.alpha*pow(x,2)-forceVars.beta*pow(y,2));
		else rForce = 0;
	}

	//Calculates angle between pobj1's bearing and the direction of repulsion force.
	rToBearing = manipulateAngle(toCartesian(pobj1.getBearing()) - rAngle);
	
	
	//Right hand rule
	//Determines if a plane should be forced to make a right turn to travel behind a plane approaching from the right.
	
	if(fieldAngle < 0 && fieldAngle > -135 && rToBearing < -90 && rToBearing > -180){
		double a = 0.0, b = 0.0, c = 0.0, A = 0.0, B = 0.0, C = 0.0;
		
		//Spherical law of cosines calculations
		
		if(fieldAngle > -25){
			a = distance / EARTH_RADIUS;
			B = -1 * fieldAngle * PI / 180;
			C = (180 - (-1 * rToBearing)) * PI / 180;

			A = acos(-cos(B)*cos(C) + sin(B)*sin(C)*cos(a));

			b = acos((cos(B) + cos(C)*cos(A))/(sin(C)*sin(A)));
			b *= EARTH_RADIUS;

			c = acos((cos(C) + cos(A)*cos(B))/(sin(A)*sin(B)));
			c *= EARTH_RADIUS;
		}

		//Angle between bearing and destination
		double aToBearing = manipulateAngle(toCartesian(pobj1.getBearing()) - aAngle);

		if((c - b) > ((-1 * rToBearing) - 90.0) && fieldAngle > -25){
			//Plane should not turn right, because it will turn into a plane
		}else if(aToBearing < 0 && fieldAngle < -90){
			//Plane should not turn right, parallel to other plane and its destination is to the left
		}else{
			//flip repulsive force across bearing to force right turn.
			rAngle = manipulateAngle(2 * (180 + rToBearing) + rAngle);
		}
	}	
	
	//calculates force felt by pobj1 based on angle, rToBearing, at which the force is applied.
	rForce = rForce * ((FRONT_FEEL-((FRONT_FEEL-BACK_FEEL)/2)) + (-0.5*(FRONT_FEEL-BACK_FEEL)) * cos(rToBearing * PI / 180));

	mathVector mV(rForce, rAngle);
	return mV;
}

/*
Calculates the direction the plane needs to head in order to reach destination
point, and sets the magnitude of this attractive force to the DEST_CHARGE.
If the plane is a follower in a swarm, it will head towards its leader.
*/
AU_UAV_ROS::mathVector AU_UAV_ROS::calculateAttractionForce(const PlaneObject &pobj1, std::map<int, PlaneObject> &pobjects){
	double aForce = 0.0, aAngle = 0.0;

	// check if the plane is a follower
	if(pobj1.getLeader() != -1) {		// the plane is a follower, have it follow its leader
	
		// Set the destination lat and lon based on the leader's position 1 second ago
		double destLat = pobjects[pobj1.getLeader()].gettMinus1Lat();
		double destLon = pobjects[pobj1.getLeader()].gettMinus1Lon();

		//Find angle of attractive force and convert the angle from cardinal to cartesian
		aAngle = toCartesian(findAngle(pobj1.getLatitude(), pobj1.getLongitude(), destLat, destLon));
	}

	else{
		//Find angle of attractive force and convert the angle from cardinal to cartesian
		aAngle = toCartesian(findAngle(pobj1.getLatitude(), pobj1.getLongitude(), 
						pobj1.getDestination().latitude, pobj1.getDestination().longitude));
	}

	//Attractive force is constant (we want the plane to always be attracted by its destination)
	mathVector mV(DEST_CHARGE, aAngle);
	return mV;
}

/* 
Modifies the total force acting on pobj1 so that the new path does not differ more than 22.5 degrees from the current 
bearing.
*/
void AU_UAV_ROS::makeForceViable(PlaneObject &pobj1, mathVector &tForce){
	//angle of UAV bearing in degrees w/ respect to cartesian coordinates
	double UAVTheta = toCartesian(pobj1.getBearing());

	//Find angle between force vector and UAV
	double deltaTheta = tForce.getDirection() - UAVTheta;

	//Make sure angle is on interval [-180, 180]
	deltaTheta = manipulateAngle(deltaTheta);

	//Only allow turns of 22.5 degrees maximum
	if (deltaTheta > MAXIMUM_TURNING_ANGLE){
		deltaTheta = MAXIMUM_TURNING_ANGLE;
	}
	else if (deltaTheta < -MAXIMUM_TURNING_ANGLE){
		deltaTheta = -MAXIMUM_TURNING_ANGLE;
	}
	
	deltaTheta += UAVTheta;

	// Make sure angle is on interval [-180, 180]
	deltaTheta = manipulateAngle(deltaTheta);				

	tForce.setDirection(toCardinal(deltaTheta));
}

/* 
Method determines if aircraft is making a maximum angle turn and is within looping distance of its destination.
If so, it finds the distance between the destination of the UAV and the center of the circle made by a looping UAV,
and determines if the destination is unreachable.
*/
bool AU_UAV_ROS::inLoop(const PlaneObject &pobj1, mathVector &tForce){
	bool inLoop = false;
	//angle of actual UAV bearing in degrees w/ respect to cartesian coordinates
	double UAVTheta = toCartesian(pobj1.getActualBearing());
	double distanceToDest = findDistance(pobj1.getLatitude(), pobj1.getLongitude(), pobj1.getDestination().latitude, pobj1.getDestination().longitude);

	//Find angle between force vector and UAV
	double deltaTheta = tForce.getDirection() - UAVTheta;

	//Make sure angle is on interval [-180, 180]
	deltaTheta = manipulateAngle(deltaTheta);

	//Check to see if attempting a maximum turn
	if (deltaTheta > MAXIMUM_TURNING_ANGLE){
		//Check for looping
		if (distanceToDest < LOOPING_DISTANCE){
			// find distance between center of "circle" made when the UAV is looping and the destination
			double centerToWaypoint = findLoopDistance(pobj1,101.25);	

			//if the centerToWaypoint distance is less than LOOP_RADIUS-COLLISION_THRESHOLD, destination will not be reached
			if(centerToWaypoint < (LOOP_RADIUS-COLLISION_THRESHOLD)){
				inLoop = true;
			}else{
				inLoop = false;
			}
		}
	}
	
	//Check to see if attempting a maximum turn
 	 if(deltaTheta < -MAXIMUM_TURNING_ANGLE){
		//Check for looping
		if (distanceToDest < LOOPING_DISTANCE){
			// find distance between center of "circle" made when the UAV is looping and the destination
			double centerToWaypoint = findLoopDistance(pobj1,-101.25);

			//if the centerToWaypoint distance is less than LOOP_RADIUS-COLLISION_THRESHOLD, destination will not be reached
			if(centerToWaypoint < (LOOP_RADIUS-COLLISION_THRESHOLD)){
				inLoop = true;
			}else{
				inLoop = false;
			}
		}
	}
	return inLoop;
}

/*
Calculates the distance between the center of "circle" generated when a plane is looping around its destination
and the plane's destination.  The angle parameter is the number of degrees to the left or right of the UAV the center of
turning is located.  The angle parameter is based off of the turning angle per second.  Because the simulator
uses straight line paths between each of the waypoints given, a looping UAV actually creates a hexadecagon.  
For example, in this code 22.5 is our turning angle. Therefore, the angle provided for this method is either 101.25 or -101.25 since 
[(180-22.5)/2 = 78.75; 78.75 + 22.5 = 101.25].
*/
double AU_UAV_ROS::findLoopDistance(const PlaneObject &pobj1, double angle){
	//actual bearing of plane in cartesian coordinates
	double UAVTheta = toCartesian(pobj1.getActualBearing());
	//Angle from bearing of plane to center of turning radius circle in cardinal coordinates.
	double bearingToCenter = toCardinal(manipulateAngle(UAVTheta+angle));

	//angular distance to center of the "circle" generated by a looping UAV
	double distToCenter = LOOP_RADIUS/EARTH_RADIUS;

	//current position of plane
	AU_UAV_ROS::waypoint position;
	position.latitude = pobj1.getLatitude();
	position.longitude = pobj1.getLongitude();
	position.altitude = pobj1.getAltitude();

	//calculate location of the center of the "circle" generated by a looping UAV
	AU_UAV_ROS::waypoint centerPosition = calculateCoordinate(position, bearingToCenter, distToCenter);

	//distance between center and destination
	double centerToWaypoint = findDistance(centerPosition.latitude, centerPosition.longitude, 
					pobj1.getDestination().latitude, pobj1.getDestination().longitude);
	
	return centerToWaypoint;
}
